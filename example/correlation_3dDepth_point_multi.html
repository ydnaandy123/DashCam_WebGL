<!DOCTYPE html>
<html lang="en">
	<head>
		<title>correlation_3dDepth_point_multi</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;

			}
			#pano_container {
				position:absolute;
				left:8px;
				top:48px;
				width:832px;
				height:416px;
				z-index:20;
				display:block;
				pointer-events:none;
				border:2px black solid;
			}
			#depth_container {
				position:absolute;
				left:8px;
				top:80px;
				width:512px;
				height:256px;
				z-index:10;
				display:block;
				pointer-events:none;
				border:2px black solid;
			}
			.hide {
				opacity:0;
				transition:opacity .5s ease-out;
			}
			.show {
				opacity:1;
				transition:opacity .5s ease-out;
			}
		</style>
	</head>

	<body>
		<div id="container" style="position:absolute; top:0px"></div>
		<div id="pano_container" class="hide"></div>
		<div id="depth_container" class="hide"></div>
		
		<script src="../src/VideoSource/pathPoint.js"></script>
		
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/../build/three.min.js"></script>

		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/controls/OrbitControls.js"></script>

		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/Detector.js"></script>
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/libs/stats.min.js"></script>
		
		<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
		
		<script type="text/javascript" src="../libs/dat.gui.min.js"></script>		

		<script src="../libs/GSVPanoDepth.js-master/examples/js/jquery.min.js" type="text/javascript"></script>
		<script src="../libs/GSVPanoDepth.js-master/examples/js/jquery.base64.min.js" type="text/javascript"></script>
		<script src="../libs/GSVPanoDepth.js-master/examples/js/zpipe.min.js" type="text/javascript"></script>		
		<script src="../libs/GSVPanoDepth.js-master/examples/js/GSVPano.js" type="text/javascript"></script>
		<script src="../libs/GSVPanoDepth.js-master/src/GSVPanoDepth.js" type="text/javascript"></script>		

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var stats;
			var camera, controls, scene, renderer;
			var svs = new google.maps.StreetViewService();
			var root_object = 0, root_helper_object = 0;
			var show_pano = false, show_depth = false;
			var point_cloud_material, point_size = 0.1;
			var traslate_x = 0, traslate_z = 0, scale=1;
			var mycanvas;
			
			var root_street_view_set=new THREE.Object3D();
			var root_helper_object_set=new THREE.Object3D();
			var length=0;
			
			var Rt = [];			
			var m0 = new THREE.Matrix4();
			m0.set( 0.9968,    0.0796,    0.0020,   21.7831,
					-0.0796,    0.9967,    0.0181,   -1.5909,
					-0.0005,   -0.0182,    0.9998,    0.5480,
					0	  ,	   0     ,         0,          1);
			var m1 = new THREE.Matrix4();
			m1.set(  0.9999,    0.0051,    0.0138,   22.4335,
					-0.0050,    1.0000,   -0.0058,   -0.7050,
					-0.0138,    0.0058,    0.9999,   -2.3004,
					0      ,         0,         0,         1);
			var m2 = new THREE.Matrix4();
			m2.set( 0.9892,    0.0003,   -0.1466,   23.1005,
					-0.0036,    0.9997,   -0.0223,   -0.2707,
					0.1465,   0.0226,    0.9889,    4.4604,
					0      ,         0,         0,         1);
			var m3 = new THREE.Matrix4();
			m3.set(  0.9996,    0.0279,    0.0053,   32.0827,
					-0.0279,    0.9995,   -0.0124,   -0.3385,
					-0.0056,    0.0123,    0.9999,    0.0488,
					0      ,         0,         0,         1);	
			var m4 = new THREE.Matrix4();
			m4.set( 1.0000,   -0.0024,    0.0002,   22.6401,
					0.0024,    0.9999,	   -0.0161,   -0.0614,
					-0.0001,    0.0161,    0.9999,    1.0708,
					0      ,         0,         0,         1);						
			Rt.push(m0);
			Rt.push(m1);
			Rt.push(m2);
			Rt.push(m3);
			Rt.push(m4);
			
			var transLate = [];
			var t0 = new THREE.Vector3(21.7831, -1.5909, 0.5480);
			var t1 = new THREE.Vector3(22.4335, -0.7050, -2.3004);
			var t2 = new THREE.Vector3(23.1005, -0.2707, 4.4604);
			var t3 = new THREE.Vector3(32.0827, -0.3385, 0.0488);
			var t4 = new THREE.Vector3(22.6401,   -0.0614,    1.0708);
			transLate.push(t0);
			transLate.push(t1);
			transLate.push(t2);
			transLate.push(t3);
			transLate.push(t4);
			
			var wX0, wY0, wZ0, earthR=20037508.34;
			var x0=0, z0=0;
			
			var panoNormal=[], panoPos=[], myCam=true;
			
			init();
			animate();			
			
			function init() {
				// scene create
				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0xcccccc, 0.001 );
				// render setting
				renderer = new THREE.WebGLRenderer({antialias: true});
				renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				// container created
				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
				// camera setting
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.y = 60;
				camera.up.set(0.0, 1.0, 0.0)
				// threejs.orbitControl added
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				//controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
				// world (x-z plane)
				var gridXZ = new THREE.GridHelper(1000, 50);
				gridXZ.setColors( new THREE.Color(0xff0000), new THREE.Color(0xffffff) );
				scene.add(gridXZ);				
				// lights
				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 );
				scene.add( light );
				light = new THREE.DirectionalLight( 0x002288 );
				light.position.set( -1, -1, -1 );
				scene.add( light );
				light = new THREE.AmbientLight( 0x222222 );
				scene.add( light );
				// state monitor
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );
				// eventListner
				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener('mousedown', on_document_mouse_down, false);
			
				// threejs PointsMaterial
				point_cloud_material = new THREE.PointsMaterial({
					size: point_size,
					vertexColors: true,
					sizeAttenuation: true,
					fog: true
				});						
				// point cloud				
				scene.add(root_street_view_set);				
				scene.add(root_helper_object_set);
				// demo			
				for(var i=0;i<=pathPoint.length/2;i++){
					render_street_point_cloud(pathPoint[2*i], pathPoint[2*i+1],i);	
				}
				// gui interface
				var gui = new dat.GUI();
				gui.add(this, "point_size", 0.1, 2.0).name("Point size").onChange(function (value) {
					point_cloud_material.size = point_size;
				});		
				gui.add(this, "scale", 0, 1).name("Scale").onChange(function (value) {
					root_helper_object_set.scale.set(scale,1,scale);
					root_street_view_set.scale.set(scale,scale,scale);
				});			
				gui.add(this, "myCam", false).name("FreeCamera").onChange(function (value) {
					console.log(myCam);
				});								
			}					

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			var start, end, speed=0.0, dir=new THREE.Vector3();
			function animate() {
				requestAnimationFrame( animate );
				if(myCam){				
					controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true
				}
				else{					
					var yoo = new THREE.Vector3(0,0,0);
					yoo.crossVectors(panoPos[1], panoNormal[1]);
					yoo.normalize();
					start = new THREE.Vector3(panoPos[1].x - yoo.x * 100,
					panoPos[1].y - yoo.y * 100, panoPos[1].z - yoo.z * 100);
					var yoo = new THREE.Vector3(0,0,0);
					yoo.crossVectors(panoPos[5], panoNormal[5]);
					yoo.normalize();
					end = new THREE.Vector3(panoPos[5].x - yoo.x * 100,
					panoPos[5].y - yoo.y * 100, panoPos[5].z - yoo.z * 100);
					dir.subVectors(end, start); 
					camera.position.x = start.x;
					camera.position.y = start.y;
					camera.position.z = start.z;
					speed = (speed + 0.005)%1;
					//camera.translateOnAxis(dir,speed);
					//camera.lookAt(pointcloud);
					//camera.translateOnAxis(panoNormal[index], 100);
					camera.lookAt(root_street_view_set.children[0].position);
					//console.log(index, panoNormal[index]);
				}				
				stats.update();
				
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}
			
			function on_document_mouse_down(event) {
			
			}			
			function render_street_point_cloud(lat, lon, index){
				var img_canvas_context = 0;
				var main_rotation = 0;
				var pano_loader = new GSVPANO.PanoLoader({
					zoom: 1
				});
				var depth_loader = new GSVPANO.PanoDepthLoader();	
				var root_street_view = new THREE.Object3D();
				//World coordinate
				var wX, wY, wZ, wR, wT;
				wZ = earthR*Math.sin(lat * Math.PI / 180.0);
				wR = earthR*Math.cos(lat * Math.PI / 180.0);
				wX = wR*Math.cos(lon * Math.PI / 360.0);
				wY = wR*Math.sin(lon * Math.PI / 360.0);
				//console.log("world coor:", wX,wY,wZ,wR, earthR);
				wT = new THREE.Vector3(wX, wY, wZ);
				if(index==0){
					wX0 = wX; wY0 = wY; wZ0 = wZ;
					wX = 0; wY = 0; wZ = 0;
				}
				else{
					wX = wX - wX0; wY = wY - wY0; wZ = wZ - wZ0;
				}
				//console.log("THREEJS coor:", wX,wY,wZ,wR);
				
				//
				var xoffs = lon * earthR /180 - x0;
				var zoffs = Math.log(Math.tan((90+lat) * Math.PI / 360)) / (Math.PI/180) * (earthR/180) - z0;
				if(index==0){
					x0 = xoffs; z0=zoffs;
					xoffs = 0; zoffs = 0;
				}
				//console.log("offs", xoffs, zoffs);
				//load pano
				pano_loader.load(new google.maps.LatLng(lat,lon));
				pano_loader.onPanoramaLoad = function () {
					root_helper_object = new THREE.Object3D();
					if (this.data.links.length > 0) {
						for (var i = 0; i < this.data.links.length; ++i) {
							if(index==1){
								//console.log(this.data.links[i].heading);
							}
							var helper_geometry_base = new THREE.Object3D();
							var helper_shape = new THREE.Shape();
							helper_shape.moveTo(0, 0);
							helper_shape.lineTo(-2, 5);
							helper_shape.lineTo(2, 5);
							helper_shape.lineTo(0, 0);
							var extrudeSettings = {
								amount: 0.25
							};
							extrudeSettings.bevelEnabled = false;
							var helper_geometry = new THREE.ExtrudeGeometry(helper_shape, extrudeSettings);
							var helper_mesh = new THREE.Mesh(helper_geometry, new THREE.MeshNormalMaterial())
							helper_mesh.rotation.x = Math.PI / 2.0;
							helper_mesh.rotation.z = Math.PI / 2.0;
							helper_mesh.position.x = 16;
							helper_mesh.userData = this.data.links[i].pano;
							helper_geometry_base.rotation.y = (this.data.links[i].heading) * Math.PI / 180.0 ;
							helper_geometry_base.add(helper_mesh);
							root_helper_object.add(helper_geometry_base);				
							root_helper_object_set.add(root_helper_object);
						}
					}					
					img_canvas_context = this.canvas.getContext('2d');
					main_rotation = this.data.tiles.centerHeading;
					depth_loader.load(this.panoId);
				};
				//load depth
				depth_loader.onDepthLoad = function () {
					var geometry = new THREE.BufferGeometry();
					var num_points = this.depthMap.width * this.depthMap.height;
					var positions = new Float32Array(num_points * 3);
					var colors = new Float32Array(num_points * 3);
					var color_data = img_canvas_context.getImageData(0, 0, img_canvas_context.canvas.width, img_canvas_context.canvas.height).data;
					var n = 0;
					for (var y = 0; y < this.depthMap.height; ++y) {
						var lat = (y / this.depthMap.height) * 180.0 - 90.0;
						var r = Math.cos(lat * Math.PI / 180.0);
						for (var x = 0; x < this.depthMap.width; ++x) {
							var depth = parseFloat(this.depthMap.depthMap[y * this.depthMap.width + (this.depthMap.width - x)]);
							if(depth>50)continue;
							var lng = ((x / this.depthMap.width)) * 360.0 - 0.0;
							var pos = new THREE.Vector3();
							pos.x = (r * Math.cos(lng * Math.PI / 180.0));
							pos.y = (Math.sin(lat * Math.PI / 180.0));
							pos.z = (r * Math.sin(lng * Math.PI / 180.0));
							pos.multiplyScalar(depth);
							pos.multiplyScalar(2.0);			
							positions[3 * n + 0] = -(isNaN(pos.x) ? 0 : pos.x);
							positions[3 * n + 1] = -(isNaN(pos.y) ? 0 : pos.y);
							positions[3 * n + 2] = -(isNaN(pos.z) ? 0 : pos.z);
							var normalized_x = (1-x / this.depthMap.width);
							var normalized_y = y / this.depthMap.height;
							var color_canvas_x = parseInt(normalized_x * img_canvas_context.canvas.width);
							var color_canvas_y = parseInt(normalized_y * img_canvas_context.canvas.height);
							var color_index = color_canvas_y * img_canvas_context.canvas.width * 4 + color_canvas_x * 4;
							colors[3 * n + 0] = (color_data[color_index + 0]) / 255.0;
							colors[3 * n + 1] = (color_data[color_index + 1]) / 255.0;
							colors[3 * n + 2] = (color_data[color_index + 2]) / 255.0;
							
							if(this.depthMap.width - x == 41 && y == 119){
								//console.log(this.depthMap.width - x,y,depth);
								//console.log(color_canvas_x, color_canvas_y);
								//console.log(pos.x, pos.y, pos.z);
							}
							if(this.depthMap.width - x == 174 && y == 146){
								//console.log(this.depthMap.width - x,y,depth);
							}
							if(this.depthMap.width - x == 420 && y == 154){
								//console.log(this.depthMap.width - x,y,depth);
							}
							n++;
						}
					}
					geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
					geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
					geometry.computeBoundingBox();
					var pointcloud = new THREE.Points(geometry, point_cloud_material);
					root_street_view.add(pointcloud);	
					
					
					//root_street_view.rotation.y = main_rotation * Math.PI / 180.0;
					for(var i=0; i<index; i++){
						//root_street_view.applyMatrix(Rt[i]);
					}
					for(var i=0; i<index; i++){
						//root_street_view.translateOnAxis(transLate[i], 1);
					}
					
					
					//root_street_view.rotation.y = main_rotation * Math.PI / 180.0;
					//root_street_view.position.x = zoffs;
					//root_street_view.position.z = -xoffs;
					
					root_street_view.position.x = wX;
					root_street_view.position.y = wY;
					root_street_view.position.z = wZ;
					root_street_view.lookAt(wT);
					
					panoPos[index] = new THREE.Vector3(wX, wY, wZ);
					panoNormal[index] = wT.normalize();
					
					//root_street_view.children[0].rotation.y = Math.PI * 0.5;
					//pointcloud.position.set(zoffs,0,-xoffs);
					//pointcloud.rotation.z = (isNaN(zz.angleTo(new THREE.Vector3(0,0,wZ)))? 0 : zz.angleTo(new THREE.Vector3(0,0,wZ)));
				}
				root_street_view_set.add(root_street_view);
			}
		</script>
	</body>
</html>
