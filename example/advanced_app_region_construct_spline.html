<!DOCTYPE html>
<html lang="en">
	<head>
		<title>advanced_app_region_construct_spline</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="mystyle.css">
	</head>

	<body>
		<div id="container" style="position:absolute; top:20px"></div>
		<div id="pano_container" class="hide"></div>	
		<div id="depth_container" class="hide"></div>
				
		<script src="../src/VideoSource/pathPoint.js"></script>
		
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/../build/three.min.js"></script>

		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/controls/OrbitControls.js"></script>
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/Detector.js"></script>
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/libs/stats.min.js"></script>
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/controls/TransformControls.js"></script>
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/renderers/Projector.js"></script>
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/controls/DragControls.js"></script>
		
		<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
		
		<script type="text/javascript" src="../libs/dat.gui.min.js"></script>		

		<script src="../libs/GSVPanoDepth.js-master/examples/js/jquery.min.js" type="text/javascript"></script>
		<script src="../libs/GSVPanoDepth.js-master/examples/js/jquery.base64.min.js" type="text/javascript"></script>
		<script src="../libs/GSVPanoDepth.js-master/examples/js/zpipe.min.js" type="text/javascript"></script>

		<script src="js/GSVPano_my2.js" type="text/javascript"></script>
		<script src="js/GSVPanoDepth_my.js" type="text/javascript"></script>	
		
		<script src='../libs/threex.text-master/threex.text.js'></script>
		<script src="../libs/threex.text-master/fonts/droid/droid_serif_bold.typeface.js"></script>
		
		
		<script>				
			
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			//THREE.js
			var camera, controls, scene, renderer, raycaster, stats;
			//SPLINE
			String.prototype.format = function () {
				var str = this;
				for ( var i = 0; i < arguments.length; i ++ ) {

					str = str.replace( '{' + i + '}', arguments[ i ] );

				}
				return str;
			}

			var container;
			var splineHelperObjects = [], splineOutline;
			var splinePointsLength = 5;
			var positions = [];
			var options;
			var geometry = new THREE.BoxGeometry( 2, 2, 2 );
			var ARC_SEGMENTS = 200;
			var splineMesh;
			var splines = {

			};			
			//GOOGLE
			var svs = new google.maps.StreetViewService();
			//DAT			
			var guiText = function() {
				this.dlPt = function(){		
					downloadPt();
				};
				this.dlMeta = function(){		
					downloadMeta();
				};
			};	
			var gui, f_baisc, f_download, guiView = new guiText(), show_pano = false, show_depth = false, trans = false;	
			//POINT CLOUD	
			var point_cloud_material, point_size = 0.1;		
			var street_view_heading_set = new THREE.Object3D();		
			var union_street_view = new THREE.Object3D();
			//----- POINT CLOUD COMPOSE -----	
			var pano_container = document.getElementById('pano_container'), dpeth_container = document.getElementById('depth_container');
			var earthR = 6371000, normal_offs, mat_offs;
			//APP
			var	panoSet = {}, panoSet_metaOnly = {}, panoIdarr = [], len=0;
			var maxDepth = 30, maxLength = 5;
			//SPLINE
			var SPTS = [], YOO=false;
			
			init();
			animate();	
					
			function init() {
			
				THREE_scene_init();		
				DAT_view();
				
				auto_surround_street('IuQFCnTWQfioXgg_V6ADRQ', 0, 1);
				//console.log(pathPoint[10], pathPoint[11]);
				//auto_center_street(pathPoint[10], pathPoint[11], 0);
			
				//----- EVENT LISTENER -----
				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener('mousedown', on_document_mouse_down, false);
			}	
			function auto_center_street(lat, lon){				
				//----- EACH SINGLE STREETVIEW -----				
				var street_view = new THREE.Object3D();						
				var street_view_heading = new THREE.Object3D();		
				var img_canvas_context = 0, main_rotation = 0;
				var pano_loader = new GSVPANO.PanoLoader({
					zoom: 1
				});
				var depth_loader = new GSVPANO.PanoDepthLoader();		
				//----- LOAD PANO (Find the nearest location)-----
				pano_loader.loadByLocation(new google.maps.LatLng(lat,lon));
				pano_loader.onPanoramaLoad = function () {
					panoIdarr.push(this.panoId);
					// Here is the PROBLEM!!
					var lat_real = this.data.Jo[this.panoId].lat;
					var lon_real = this.data.Jo[this.panoId].lng;
					panoSet[this.panoId] = {lat:lat_real, lon:lon_real};						
					// Get Panoramic
					pano_container.appendChild(this.canvas);	
					panoSet[this.panoId].panoC = this.canvas;
					// Get Other Links
					var root_helper_object = new THREE.Object3D();				
					//createLinks(root_helper_object, this.data);
					
					street_view_heading.add(root_helper_object);
					street_view_heading_set.add(street_view_heading);
					// Store PANO and HEADING, then call depth_loader
					img_canvas_context = this.canvas.getContext('2d');
					main_rotation = this.data.tiles.centerHeading;
					panoSet[this.panoId].rotation = -main_rotation * Math.PI / 180.0;
					depth_loader.load(this.panoId);
				};				
				//----- LOAD DEPTH -----
				depth_loader.onDepthLoad = function () {		
					var index=0;							
					// Depth Map
					drawDepthMap(this.depthMap);
					panoSet[Object.keys(panoSet)[index]].depthC = depth_container.children[index];
					// Create Point Cloud
					var geometry = new THREE.BufferGeometry();
					createPointCloud(geometry, this.depthMap, img_canvas_context);			
					//World Axis to THREE.js Axis
					var wT = new THREE.Vector3;
					computeWorldAxis(panoSet[Object.keys(panoSet)[index]].lat, panoSet[Object.keys(panoSet)[index]].lon, wT);		
					panoSet[Object.keys(panoSet)[index]].normal = wT.clone();
					normal_offs = new THREE.Vector3(wT.x, wT.y, wT.z);	
					//----- World objects Regeisterd in GLWorld -----		
					street_view.rotation.y = -main_rotation * Math.PI / 180.0;	
					registeredInGLWorld(wT, street_view_heading);
				
					street_view.updateMatrix();
					street_view_heading.updateMatrix();	
					var matrix = new THREE.Matrix4().multiplyMatrices(street_view_heading.matrix, street_view.matrix);	
					panoSet[Object.keys(panoSet)[index]].matrix = matrix;
					mat_offs = matrix.clone();
					
					geometry.applyMatrix(matrix);
					var pointcloud = new THREE.Points(geometry, point_cloud_material);
					union_street_view.add(pointcloud);
					
					panoSet[Object.keys(panoSet)[index]].buffer_geometry = geometry;	
					
					// Sequence Download Pano
					//panoIdarr.push('paxmh-ida4H3e2NeUIQ1tw');
					len = panoIdarr.length;
					for(var i=0 ; i<len; i++){
						auto_surround_street(panoIdarr[i], i);
					}
				}	
			}			
			function auto_surround_street(panoId, index, dir){	
				//----- EACH SINGLE STREETVIEW -----				
				var street_view = new THREE.Object3D();						
				var street_view_heading = new THREE.Object3D();		
				var img_canvas_context = 0, main_rotation = 0;
				var pano_loader = new GSVPANO.PanoLoader({
					zoom: 1
				});
				var depth_loader = new GSVPANO.PanoDepthLoader();		
				//----- LOAD PANO (Find the nearest location)-----
				pano_loader.loadById(panoId);
				pano_loader.onPanoramaLoad = function () {
					// Here is the PROBLEM!!
					var lat_real = this.data.Jo[panoId].lat;
					var lon_real = this.data.Jo[panoId].lng;
					panoSet[panoId] = {lat:lat_real, lon:lon_real};	
					//panoSet_metaOnly[panoId] = {index: index, lat:lat_real, lon:lon_real};	
					panoSet_metaOnly[index] = {panoId: panoId, lat:lat_real, lon:lon_real};	
					// Get Panoramic
					pano_container.appendChild(this.canvas);	
					panoSet[panoId].panoC = this.canvas;
					// Get Other Links
					var root_helper_object = new THREE.Object3D();
					createLinks(root_helper_object, this.data, index, dir);
					street_view_heading.add(root_helper_object);
					street_view_heading_set.add(street_view_heading);
					// Store PANO and HEADING, then call depth_loader
					img_canvas_context = this.canvas.getContext('2d');
					main_rotation = this.data.tiles.centerHeading;
					panoSet[panoId].rotation = -main_rotation * Math.PI / 180.0;
					depth_loader.load(panoId);
				};				
				//----- LOAD DEPTH -----
				depth_loader.onDepthLoad = function () {				
					// Depth Map					
					drawDepthMap(this.depthMap);
					panoSet[panoId].depthC = depth_container.children[index];
					// Create Point Cloud
					var geometry = new THREE.BufferGeometry();					
					createPointCloud(geometry, this.depthMap, img_canvas_context);
					//World Axis to THREE.js Axis
					var wT = new THREE.Vector3;
					computeWorldAxis(panoSet[panoId].lat, panoSet[panoId].lon, wT);		
					panoSet[panoId].normal = wT.clone();
					if(index==0){
						normal_offs = new THREE.Vector3(wT.x, wT.y, wT.z);	
					}					
					//----- World objects Regeisterd in GLWorld -----		
					street_view.rotation.y = -main_rotation * Math.PI / 180.0;	
					registeredInGLWorld(wT, street_view_heading);
				
					street_view.updateMatrix();
					street_view_heading.updateMatrix();	
					var matrix = new THREE.Matrix4().multiplyMatrices(street_view_heading.matrix, street_view.matrix);	
					panoSet[panoId].matrix = matrix;
					if(index==0){
						mat_offs = matrix.clone();
					}
					
					geometry.applyMatrix(matrix);
					var pointcloud = new THREE.Points(geometry, point_cloud_material);
					union_street_view.add(pointcloud);
					addSplineObject(new THREE.Vector3().subVectors(wT,  normal_offs))
					SPTS.push(pointcloud);
					//myaddSplineObject(pointcloud);
					console.log(new THREE.Vector3().subVectors(wT,  normal_offs));
					panoSet[panoId].buffer_geometry = geometry;	
					
					index++;
					len = panoIdarr.length;
					if(index==len && index<maxLength){
						console.log(index, panoIdarr[index-1]);
						auto_surround_street(panoIdarr[index-1], index, dir);						
					}
					else{						
						console.log(panoSet);	
						YOO = true;
						createSpline();
						/*$.each(actual_JSON, function(keyFrame, valFrame){	
							$.each(valFrame, function(keyLocation, valLocation){
								XYZobj[keyFrame][keyLocation] = [];
								for(var i=0; i<valLocation.length; i++)	{
									XYZobj[keyFrame][keyLocation].push(panoSet[keyLocation].buffer_geometry.attributes.position.array[valLocation[i]*3]);
									XYZobj[keyFrame][keyLocation].push(panoSet[keyLocation].buffer_geometry.attributes.position.array[valLocation[i]*3+1]);
									XYZobj[keyFrame][keyLocation].push(panoSet[keyLocation].buffer_geometry.attributes.position.array[valLocation[i]*3+2]);																											
								}				
							});	
						});													
						console.log(XYZobj);	
						f_confirm.add(guiView, "slPt", false).name("Select point");	
						f_confirm.add(guiView, "slGroup", false).name("Select group");	
						f_download.add(guiView, "dlPt").name("Download pt");*/	
					}					
					/*if(index==len && index<maxLength){
						len = panoIdarr.length;
						for(var i=index; i<len; i++){
							console.log(i);
							auto_surround_street(panoIdarr[i], i);
						}					
					}
					else if(index==len && index>=maxLength){
						console.log(panoSet_metaOnly);	
						f_download.add(guiView, "dlMeta").name("Download Meta");					
					}*/
					// Sequence Download Pano
					//auto_surround_street(Object.keys(panoSet)[index], index);		
				}	
			}	
			function createLinks(root_helper_object, data, index, dir){
				if (data.links.length > 0) {
					for (var i = 0; i < data.links.length; ++i) {
						// Draw arrow
						var helper_geometry_base = new THREE.Object3D();
						var helper_shape = new THREE.Shape();
						helper_shape.moveTo(0, 0);
						helper_shape.lineTo(-0.6, 1.25);
						helper_shape.lineTo(0.6, 1.25);
						helper_shape.lineTo(0, 0);
						var extrudeSettings = {
							amount: 0.25
						};
						extrudeSettings.bevelEnabled = false;
						var helper_geometry = new THREE.ExtrudeGeometry(helper_shape, extrudeSettings);
						var helper_mesh = new THREE.Mesh(helper_geometry, new THREE.MeshNormalMaterial())
						// Rotate heading && Place it
						helper_mesh.userData = data.links[i].pano;
						if(panoSet[helper_mesh.userData] == undefined && i == dir){
							console.log(data.links[i])
							panoSet[helper_mesh.userData] = {};
							panoIdarr.push(helper_mesh.userData);
						}
						helper_mesh.rotation.x = Math.PI / 2.0;
						helper_mesh.position.z = -5;
						helper_geometry_base.rotation.y = -data.links[i].heading * Math.PI / 180;
						helper_geometry_base.add(helper_mesh);
						
						var mesh = new THREEx.Text(index)
						mesh.scale.multiplyScalar(2)
						mesh.position.y	= +0.6
						root_helper_object.add(mesh)
	
						root_helper_object.add(helper_geometry_base);
					}
				}				
			}	
			function createPointCloud(geometry, depthMap, img_canvas_context){
				var color_data = img_canvas_context.getImageData(0, 0, img_canvas_context.canvas.width, img_canvas_context.canvas.height).data;									
				var geometryTexture = new THREE.BufferGeometry();
				var num_points = depthMap.width * depthMap.height;
				var positions = new Float32Array(num_points * 3);
				var colors = new Float32Array(num_points * 3);					
				var n = 0;						
				for (var y = 0; y < depthMap.height; ++y) {
					var lat = -(y / depthMap.height) * 180.0 + 90.0;
					var r = Math.cos(lat * Math.PI / 180.0);
					for (var x = 0; x < depthMap.width; ++x) {	
						var depth = parseFloat(depthMap.depthMap[y * depthMap.width + x]);
						if(depth>maxDepth)continue;
						// Panoromic to Spherical							
						var lng = (x / depthMap.width) * 360.0 - 180.0;
						// Spherical Axis to THREE.js Axis
						var pos = new THREE.Vector3();
						pos.y = Math.sin(lat * Math.PI / 180.0);
						pos.x = (r * Math.sin(lng * Math.PI / 180.0));
						pos.z = -(r * Math.cos(lng * Math.PI / 180.0)); // IMPORTANT!!!!
						// Multiple by Depth
						pos.multiplyScalar(depth);
						// Store Position and Color of Each Point
						positions[3 * n + 0] = isNaN(pos.x) ? 0 : pos.x;
						positions[3 * n + 1] = isNaN(pos.y) ? 0 : pos.y;
						positions[3 * n + 2] = isNaN(pos.z) ? 0 : pos.z;
						var color_canvas_x = parseInt((x / depthMap.width) * img_canvas_context.canvas.width);
						var color_canvas_y = parseInt((y / depthMap.height) * img_canvas_context.canvas.height);
						var color_index = color_canvas_y * img_canvas_context.canvas.width * 4 + color_canvas_x * 4;							
						colors[3 * n + 0] = (color_data[color_index + 0]) / 255.0;
						colors[3 * n + 1] = (color_data[color_index + 1]) / 255.0;
						colors[3 * n + 2] = (color_data[color_index + 2]) / 255.0;											
						n++;
					}
				}						
				// Point Cloud geometry
				geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
				geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
				geometry.computeBoundingBox();		
			}
			function downloadPt(){
				var hiddenElement = document.createElement('a');
				console.log('start');				
				var XYZdata = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(XYZobj));				
				console.log('finish');
				hiddenElement.href = 'data:' + XYZdata;				
				hiddenElement.innerHTML = 'download JSON';
				hiddenElement.target = '_blank';
				hiddenElement.download = 'data.json';
				hiddenElement.click();
				console.log('download');				
			}				
			function downloadMeta(){
				var hiddenElement = document.createElement('a');
				console.log('start');				
				var XYZdata = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(panoSet_metaOnly));				
				console.log('finish');
				hiddenElement.href = 'data:' + XYZdata;				
				hiddenElement.innerHTML = 'download JSON';
				hiddenElement.target = '_blank';
				hiddenElement.download = 'metaOnly.json';
				hiddenElement.click();
				console.log('download');				
			}				
			function registeredInGLWorld(wT, street_view_heading){
				street_view_heading.lookAt(wT);
				street_view_heading.rotateOnAxis(new THREE.Vector3(1,0,0), Math.PI/2);
				street_view_heading.position.x = wT.x - normal_offs.x;
				street_view_heading.position.y = wT.y - normal_offs.y;
				street_view_heading.position.z = wT.z - normal_offs.z;			
			}			
			function computeWorldAxis(lat, lon, wT){				
				var wX, wY, wZ, wR;
				wR = earthR*Math.cos(lat * Math.PI / 180.0);
				wY = earthR*Math.sin(lat * Math.PI / 180.0);
				wX = wR*Math.sin(lon * Math.PI / 180.0);
				wZ = wR*Math.cos(lon * Math.PI / 180.0);
				wT.x = wX; wT.y = wY; wT.z = wZ;
			}				
			function drawDepthMap(depthMap){
				var canvas = document.createElement("canvas");
				var context = canvas.getContext('2d');
				canvas.setAttribute('width', depthMap.width);
				canvas.setAttribute('height', depthMap.height);
				var image = context.getImageData(0, 0, depthMap.width, depthMap.height);
				for (var y = 0; y < depthMap.height; ++y) {
					for (var x = 0; x < depthMap.width; ++x) {
						var col = depthMap.depthMap[y * depthMap.width + x] / 50 * 255;
						image.data[4 * (y * depthMap.width + x) + 0] = col;
						image.data[4 * (y * depthMap.width + x) + 1] = col;
						image.data[4 * (y * depthMap.width + x) + 2] = col;
						image.data[4 * (y * depthMap.width + x) + 3] = 255;
					}
				}					
				context.putImageData(image, 0, 0);
				vdpeth_container = document.getElementById('depth_container');
				depth_container.appendChild(canvas);				
			}			
			function DAT_view(){
				//----- DAT GUI -----
				gui = new dat.GUI();
				f_baisc = gui.addFolder('Basic');
				f_baisc.open();
				f_download = gui.addFolder('download');
				f_download.open();
				
				f_baisc.add(this, "point_size", 0.1, 2.0).name("Point size").onChange(function (value) {
					point_cloud_material.size = point_size;
				});	
				f_baisc.add(this, "show_pano", false).name("Show pano image").onChange(function (value) {
					if (value)
						document.getElementById("pano_container").className = "show";
					else
						document.getElementById("pano_container").className = "hide";
				});
				f_baisc.add(this, "show_depth", false).name("Show depth").onChange(function (value) {
					if (value)
						document.getElementById("depth_container").className = "show";
					else
						document.getElementById("depth_container").className = "hide";
				});			
				f_baisc.add(this, "trans", false).name("Axis trans").onChange(function (value) {
					if (value){
						union_street_view.applyMatrix(new THREE.Matrix4().getInverse(mat_offs));
						street_view_heading_set.applyMatrix(new THREE.Matrix4().getInverse(mat_offs));
					}						
					else{
						union_street_view.applyMatrix(mat_offs);
						street_view_heading_set.applyMatrix(mat_offs);
					}						
				});	
			}
			function THREE_scene_init(){
				//----- THREE.JS OBJECT -----
				// Scene Create
				scene = new THREE.Scene();
				// Render
				renderer = new THREE.WebGLRenderer({
					antialias: true
				});				
				renderer.setClearColor( 0xffffff );
				renderer.setSize(window.innerWidth, window.innerHeight);
				// Container Created
				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );	
				// Camera Setting				
				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
				camera.position.set(0, 50, 0);
				camera.lookAt(0.0, 0.0, 0.0);
				camera.up.set(0.0, 1.0, 0.0)
				// Lights	
				light = new THREE.AmbientLight( 0xffffff );
				scene.add( light );
				// Controls && Project
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				raycaster = new THREE.Raycaster();
				// State Monitor
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );			
				// point cloud material
				point_cloud_material = new THREE.PointsMaterial({
					size: point_size,
					vertexColors: true,
					sizeAttenuation: true,
					fog: true
				});						
				// Point Cloud Objects
				scene.add(street_view_heading_set);	
				//scene.add(street_view_heading);
				scene.add(union_street_view);
				// world (x-z plane)
				var gridXZ = new THREE.GridHelper(1000, 50);
				gridXZ.setColors( new THREE.Color(0xff0000), new THREE.Color(0xffffff) );
				scene.add(gridXZ);		
				// spline
				initiateSpline();
				
			}			
			function initiateSpline(){			
				transformControl = new THREE.TransformControls( camera, renderer.domElement );
				transformControl.addEventListener( 'change', render );

				scene.add( transformControl );			
				// Hiding transform situation is a little in a mess :()
				transformControl.addEventListener( 'change', function( e ) {

					cancelHideTransorm();

				} );

				transformControl.addEventListener( 'mouseDown', function( e ) {

					cancelHideTransorm();

				} );

				transformControl.addEventListener( 'mouseUp', function( e ) {

					delayHideTransform();

				} );

				transformControl.addEventListener( 'objectChange', function( e ) {

					updateSplineOutline();

				} );

				var dragcontrols = new THREE.DragControls( camera, splineHelperObjects, renderer.domElement ); //

				dragcontrols.on( 'hoveron', function( e ) {

					transformControl.attach( e.object );
					cancelHideTransorm(); // *

				} )

				dragcontrols.on( 'hoveroff', function( e ) {

					if ( e ) delayHideTransform();

				} )


				controls.addEventListener( 'start', function() {

					cancelHideTransorm();

				} );

				controls.addEventListener( 'end', function() {

					delayHideTransform();

				} );

				var hiding;

				function delayHideTransform() {

					cancelHideTransorm();
					hideTransform();

				}

				function hideTransform() {

					hiding = setTimeout( function() {

						transformControl.detach( transformControl.object );

					}, 2500 )

				}

				function cancelHideTransorm() {

					if ( hiding ) clearTimeout( hiding );

				}
				/*load( [ new THREE.Vector3( 0, 0, 0 ),
						new THREE.Vector3( -53.56300074753207, 171.49711742836848, -14.495472686253045 ),
						new THREE.Vector3( -91.40118730204415, 176.4306956436485, -6.958271935582161 ),
						new THREE.Vector3( -383.785318791128, 491.1365363371675, 47.869296953772746 ) ] );	*/
			}
			function createSpline(){
				var i;
				/*for ( i = 0; i < splinePointsLength; i ++ ) {

					addSplineObject( positions[ i ] );

				}*/
				positions = [];
				for ( i = 0; i < splinePointsLength; i ++ ) {

					positions.push( splineHelperObjects[ i ].position );

				}

				var geometry = new THREE.Geometry();

				for ( var i = 0; i < ARC_SEGMENTS; i ++ ) {

					geometry.vertices.push( new THREE.Vector3() );

				}

				var curve;


				curve = new THREE.CatmullRomCurve3( positions );
				curve.type = 'catmullrom';
				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0xff0000,
					opacity: 0.35,
					linewidth: 2
					} ) );
				curve.mesh.castShadow = true;
				splines.uniform = curve;

				curve = new THREE.CatmullRomCurve3( positions );
				curve.type = 'centripetal';
				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0x00ff00,
					opacity: 0.35,
					linewidth: 2
					} ) );
				curve.mesh.castShadow = true;
				splines.centripetal = curve;

				curve = new THREE.CatmullRomCurve3( positions );
				curve.type = 'chordal';
				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0x0000ff,
					opacity: 0.35,
					linewidth: 2
					} ) );
				curve.mesh.castShadow = true;
				splines.chordal = curve;

				for ( var k in splines ) {
					var spline = splines[ k ];
					scene.add( spline.mesh );
				}			
			}
			function addSplineObject( position ) {
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( {
					color: Math.random() * 0xffffff
					} ) );
				object.material.ambient = object.material.color;
				if ( position ) {
					object.position.copy( position );
				} else {
					object.position.x = Math.random() * 1000 - 500;
					object.position.y = Math.random() * 600
					object.position.z = Math.random() * 800 - 400;
				}
				object.castShadow = true;
				object.receiveShadow = true;
				scene.add( object );
				splineHelperObjects.push( object );
				return object;
			}
			function myaddSplineObject( pt ) {
				var object = pt;
				object.castShadow = true;
				object.receiveShadow = true;
				scene.add( object );
				splineHelperObjects.push( object );
				return object;
			}			
			function myaddPoint(position, pt) {
				splinePointsLength ++;
				positions.push(position);
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( {
					color: Math.random() * 0xffffff
					} ) );
				object.material.ambient = object.material.color;
				object.position.copy( position );
				object.castShadow = true;
				object.receiveShadow = true;
				//scene.add( object );
				splineHelperObjects.push( pt );				
				updateSplineOutline();
			}			
			function addPoint() {
				splinePointsLength ++;
				positions.push( addSplineObject()
								.position );
				updateSplineOutline();
			}
			function removePoint() {
				if ( splinePointsLength <= 4 ) {

					return;

				}
				splinePointsLength --;
				positions.pop();
				scene.remove( splineHelperObjects.pop() );
				updateSplineOutline();
			}
			function updateSplineOutline() {
				var p;
				for ( var k in splines ) {
					var spline = splines[ k ];
					splineMesh = spline.mesh;
					for ( var i = 0; i < ARC_SEGMENTS; i ++ ) {
						p = splineMesh.geometry.vertices[ i ];
						p.copy( spline.getPoint( i /  ( ARC_SEGMENTS - 1 ) ) );
					}
					splineMesh.geometry.verticesNeedUpdate = true;
				}
			}
			function exportSpline() {
				var p;
				var strplace = [];
				for ( i = 0; i < splinePointsLength; i ++ ) {
					p = splineHelperObjects[ i ].position;
					strplace.push( 'new THREE.Vector3({0}, {1}, {2})'.format( p.x, p.y, p.z ) )
				}
				console.log( strplace.join( ',\n' ) );
				var code = '[' + ( strplace.join( ',\n\t' ) ) + ']';
				prompt( 'copy and paste code', code );
			}
			function load( new_positions ) {
				while ( new_positions.length > positions.length ) {
					addPoint();
				}
				while ( new_positions.length < positions.length ) {
					removePoint();
				}
				for ( i = 0; i < positions.length; i ++ ) {
					positions[ i ].copy( new_positions[ i ] );
				}
				updateSplineOutline();
			}			
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true
				transformControl.update();
				stats.update();
				
				render();
			}
			function render() {
				if(YOO){				
					for(var i=0; i<maxLength; i++){					
						SPTS[i].position.copy( splineHelperObjects[i].position );
					}
				}
				/*if(splines.uniform != undefined && splines.centripetal != undefined && splines.chordal != undefined){
					splines.uniform.mesh.visible = uniform.checked;
					splines.centripetal.mesh.visible = centripetal.checked;
					splines.chordal.mesh.visible = chordal.checked;
					console.log('hi');
				}*/
				renderer.render( scene, camera );
			}			
			function on_document_mouse_down(event) {			
			}
		</script>
	
	</body>
</html>
