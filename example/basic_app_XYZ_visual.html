<!DOCTYPE html>
<html lang="en">
	<head>
		<title>simple_3d_reconstruct_auto</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="mystyle.css">
	</head>

	<body>
		<div id="container" style="position:absolute; top:0px"></div>
		<div id="pano_container" class="hide"></div>	
		<div id="depth_container" class="hide"></div>
				
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/../build/three.min.js"></script>

		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/controls/OrbitControls.js"></script>
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/Detector.js"></script>
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/libs/stats.min.js"></script>
		
		<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
		
		<script type="text/javascript" src="../libs/dat.gui.min.js"></script>		

		<script src="../libs/GSVPanoDepth.js-master/examples/js/jquery.min.js" type="text/javascript"></script>
		<script src="../libs/GSVPanoDepth.js-master/examples/js/jquery.base64.min.js" type="text/javascript"></script>
		<script src="../libs/GSVPanoDepth.js-master/examples/js/zpipe.min.js" type="text/javascript"></script>

		<script src="js/GSVPano_my.js" type="text/javascript"></script>
		<script src="js/GSVPanoDepth_my.js" type="text/javascript"></script>		
		<script src="js/myPlane.js" type="text/javascript"></script>			
		
		<script>				
			
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			//Macapa,+AP,+¤Ú¦è
			//var pathPoint = [0.0324526,-51.0540268,0.0324385,-51.0538503,0.032426,-51.0536955,0.0324132,-51.0535362,0.0324028,-51.0534036,0.0324558,-51.0534274,0.0325456,-51.053422,0.0326443,-51.053416,0.032743,-51.05341,0.0329202,-51.0533991,0.0330548,-51.0533907,0.0332523,-51.0533784,0.033351,-51.0533722,0.0334596,-51.0533698,0.0335965,-51.0533633,0.0337711,-51.053345,0.0338696,-51.0533357,0.0339681,-51.0533263,0.0340576,-51.0533178,0.0341471,-51.0533093,0.0342367,-51.0533008];
			//Alta, Finnmark, Norge
			//var pathPoint = [69.9651823,23.27458,69.9650853,23.2747391,69.9650992,23.2748066,69.9651455,23.2750316,69.9652377,23.2754752,69.9652822,23.275689,69.9653305,23.2759206,69.9654362,23.2762605,69.9655197,23.2761058,69.9656109,23.2759371,69.9657532,23.2756268,69.9659061,23.2752685,69.9660671,23.2750026,69.9662141,23.2747421,69.9662105,23.2742806,69.9661245,23.2738803,69.9660845,23.273667,69.966048,23.2734562,69.9659841,23.2732486,69.9659011,23.273342,69.9657629,23.2735705,69.965692,23.2737075,69.9656183,23.2738,69.9655278,23.2740164,69.9654417,23.2741487,69.9653604,23.2742898,69.9652699,23.2744373];
			//Brighton Parade Southport, Queensland
			//var pathPoint = [-27.9779648,153.4160037,-27.978041,153.4158222,-27.9780782,153.4157334,-27.9781277,153.4156131,-27.9781771,153.4154975,-27.9782212,153.4153945,-27.9782604,153.4152917,-27.9782988,153.4151913,-27.9783499,153.4150954,-27.978401,153.4149995,-27.9784791,153.4148724,-27.9785428,153.4147886,-27.978688,153.4146426,-27.9788502,153.4145254,-27.9789304,153.4144834,-27.9790643,153.4144352,-27.9791919,153.4144129,-27.9793457,153.4144202,-27.9794594,153.4144285,-27.9795749,153.414437,-27.9796878,153.4144453,-27.9798556,153.4144585,-27.9800352,153.4144477,-27.9802593,153.4144176,-27.9804996,153.4143779] 

			//THREE.js
			var camera, controls, scene, renderer, raycaster, stats;
			//GOOGLE
			var svs = new google.maps.StreetViewService();
			//DAT
			var show_pano = false, show_depth = false, trans = false;
			//POINT CLOUD
			var point_cloud_material, point_size = 0.1;			
			var street_view_heading_set = new THREE.Object3D();			
			//----- THREE SURFACE -----
			var planeLeft = [], planeRight = [], planeGnd = [];
			//----- POINT CLOUD COMPOSE -----	
			var wX0, wY0, wZ0, earthR = 6371000;
			var color_set = [], matrix_set = [], rotation_set = [], normal_set = [], normal_offs;
			//DEMO
			var pathStart = 0, pathLen = 2, pathPoint = [];
			//APP
			var demoText = function() {
			  this.imageIndex = '0';
			  this.ptIndex = '62459';
			  this.pano_x = '0';
			  this.pano_y = '0';
			  this.depth_x = '0';
			  this.depth_y = '0';
			};
			var text = new demoText();						
			
			init();
			animate();			
					
			function init() {
							
				loadJSON(function(response) {
					parseJSONrespone(response);
				});
				THREE_scene_init();				
				DAT_view();
							
				//----- EVENT LISTENER -----
				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener('mousedown', on_document_mouse_down, false);
			}	
			function auto_center_street(lat, lon, index){
				//----- EACH SINGLE STREETVIEW -----
				var img_canvas_context = 0, main_rotation = 0;
				var pano_loader = new GSVPANO.PanoLoader({
					zoom: 1
				});
				var depth_loader = new GSVPANO.PanoDepthLoader();	
				var street_view = new THREE.Object3D();	
				var street_view_heading = new THREE.Object3D();	
				//World Axis to THREE.js Axis
				var wT = new THREE.Vector3;
				computeWorldAxis(lat, lon, wT);	
				normal_set[index] = new THREE.Vector3(wT.x, wT.y, wT.z);				
				//----- LOAD PANO -----
				pano_loader.load(new google.maps.LatLng(lat,lon));
				pano_loader.onPanoramaLoad = function () {
					// Get Panoramic
					var pano_container = document.getElementById('pano_container');
					pano_container.appendChild(this.canvas);	
					// Get Other Links
					var root_helper_object = new THREE.Object3D();
					if (this.data.links.length > 0) {
						for (var i = 0; i < this.data.links.length; ++i) {
							// Draw arrow
							var helper_geometry_base = new THREE.Object3D();
							var helper_shape = new THREE.Shape();
							helper_shape.moveTo(0, 0);
							helper_shape.lineTo(-0.6, 1.25);
							helper_shape.lineTo(0.6, 1.25);
							helper_shape.lineTo(0, 0);
							var extrudeSettings = {
								amount: 0.25
							};
							extrudeSettings.bevelEnabled = false;
							var helper_geometry = new THREE.ExtrudeGeometry(helper_shape, extrudeSettings);
							var helper_mesh = new THREE.Mesh(helper_geometry, new THREE.MeshNormalMaterial())
							// Rotate heading && Place it
							helper_mesh.userData = this.data.links[i].pano;
							helper_mesh.rotation.x = Math.PI / 2.0;
							helper_mesh.position.z = -5;
							helper_geometry_base.rotation.y = -this.data.links[i].heading * Math.PI / 180;
							helper_geometry_base.add(helper_mesh);
							root_helper_object.add(helper_geometry_base);
						}
					}					
					street_view_heading.add(root_helper_object);
					// Store PANO and HEADING, then call depth_loader
					img_canvas_context = this.canvas.getContext('2d');
					main_rotation = this.data.tiles.centerHeading;
					depth_loader.load(this.panoId);
				};				
				//----- LOAD DEPTH -----
				depth_loader.onDepthLoad = function () {
					// Ground Map
					var color_data = img_canvas_context.getImageData(0, 0, img_canvas_context.canvas.width, img_canvas_context.canvas.height).data;
					color_set[index] = color_data;
					drawDepthMap(this.depthMap);
					
					// Create Point Cloud
					var geometry = new THREE.BufferGeometry();
					var geometryTexture = new THREE.BufferGeometry();
					var num_points = this.depthMap.width * this.depthMap.height;
					var positions = new Float32Array(num_points * 3);
					var colors = new Float32Array(num_points * 3);					
					var n = 0;						
					for (var y = 0; y < this.depthMap.height; ++y) {
						var lat = -(y / this.depthMap.height) * 180.0 + 90.0;
						var r = Math.cos(lat * Math.PI / 180.0);
						for (var x = 0; x < this.depthMap.width; ++x) {
							// Plane
							var planeIndex = this._data.indices[y*this.depthMap.width + x];
							var planeN = new THREE.Vector3(-this._data.planes[planeIndex].n[0], -this._data.planes[planeIndex].n[2], -this._data.planes[planeIndex].n[1]);
							var planeD = this._data.planes[planeIndex].d;	
							var depth = parseFloat(this.depthMap.depthMap[y * this.depthMap.width + x]);
							//if(depth>30) continue;
							// Panoromic to Spherical							
							var lng = (x / this.depthMap.width) * 360.0 - 180.0;
							// Spherical Axis to THREE.js Axis
							var pos = new THREE.Vector3();
							pos.y = Math.sin(lat * Math.PI / 180.0);
							pos.x = (r * Math.sin(lng * Math.PI / 180.0));
							pos.z = -(r * Math.cos(lng * Math.PI / 180.0)); // IMPORTANT!!!!
							// Multiple by Depth
							pos.multiplyScalar(depth);
							// Store Position and Color of Each Point
							positions[3 * n + 0] = isNaN(pos.x) ? 0 : pos.x;
							positions[3 * n + 1] = isNaN(pos.y) ? 0 : pos.y;
							positions[3 * n + 2] = isNaN(pos.z) ? 0 : pos.z;
							var color_canvas_x = parseInt((x / this.depthMap.width) * img_canvas_context.canvas.width);
							var color_canvas_y = parseInt((y / this.depthMap.height) * img_canvas_context.canvas.height);
							var color_index = color_canvas_y * img_canvas_context.canvas.width * 4 + color_canvas_x * 4;							
							colors[3 * n + 0] = (color_data[color_index + 0]) / 255.0;
							colors[3 * n + 1] = (color_data[color_index + 1]) / 255.0;
							colors[3 * n + 2] = (color_data[color_index + 2]) / 255.0;											
							n++;
						}
					}						
					// Point Cloud geometry
					geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
					geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
					geometry.computeBoundingBox();
					//console.log(geometry.toJSON());
					var pointcloud = new THREE.Points(geometry, point_cloud_material);
					street_view.add(pointcloud);
					
					rotation_set[index] = -main_rotation * Math.PI / 180.0;
					street_view.rotation.y = -main_rotation * Math.PI / 180.0;	
					street_view_heading.add(street_view);	
					
					if(index==0){
						//var dir = wT.clone().normalize().multiplyScalar(50);						
						//camera.position.set(dir.x, dir.y, dir.z);
						//camera.lookAt(0.0, 0.0, 0.0);
						normal_offs = new THREE.Vector3(wT.x, wT.y, wT.z);		
					}	
					//----- World objects Regeisterd in GLWorld -----		
					registeredInGLWorld(wT, street_view_heading);
				
					street_view.updateMatrix();
					street_view_heading.updateMatrix();	
					matrix_set[index] = new THREE.Matrix4().multiplyMatrices(street_view_heading.matrix, street_view.matrix);					
					
					street_view_heading_set.add(street_view_heading);									
					//sequence downloading pano
					if(index+1<pathLen){
						index++;
						auto_center_street(pathPoint[2*index], pathPoint[2*index+1],index);							
					}
					else{
						//console.log(street_view_heading_set);
					}					
				}	
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true
				stats.update();
				
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}
			
			function on_document_mouse_down(event) {			
			}		
			function parseJSONrespone(response){
				// Parse JSON string into object
				var actual_JSON = JSON.parse(response);
				var first = true;
				$.each(actual_JSON, function(keyFrame, valFrame){
					$.each(valFrame, function(keyLocation, valLocation){
						if(first){
							var loc = keyLocation.split(",")			
							pathPoint.push(parseFloat(loc[0]), parseFloat(loc[1]));
						}
						for(var i=0; i<valLocation.length; i++)	{
							//console.log(valLocation[i]);
						}
					});		
					first = false;
				});		
				pathLen = pathPoint.length/2;				
				pathPoint = pathPoint.slice(pathStart*2, (pathStart+pathLen)*2);
				auto_center_street(pathPoint[0], pathPoint[1], 0);				
			}			
			function loadJSON(callback) {   
				var xobj = new XMLHttpRequest();
					xobj.overrideMimeType("application/json");
				xobj.open('GET', 'json/info_3d_00002.json', true); // Replace 'my_data' with the path to your file
				xobj.onreadystatechange = function () {
					  if (xobj.readyState == 4 && xobj.status == "200") {
						// Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
						callback(xobj.responseText);
					  }
				};
				xobj.send(null);  
			}				
			function registeredInGLWorld(wT, street_view_heading){
				street_view_heading.lookAt(wT);
				street_view_heading.rotateOnAxis(new THREE.Vector3(1,0,0), Math.PI/2);
				street_view_heading.position.x = wT.x - normal_offs.x;
				street_view_heading.position.y = wT.y - normal_offs.y;
				street_view_heading.position.z = wT.z - normal_offs.z;			
			}			
			function computeWorldAxis(lat, lon, wT){				
				var wX, wY, wZ, wR;
				wR = earthR*Math.cos(lat * Math.PI / 180.0);
				wY = earthR*Math.sin(lat * Math.PI / 180.0);
				wX = wR*Math.sin(lon * Math.PI / 180.0);
				wZ = wR*Math.cos(lon * Math.PI / 180.0);
				wT.x = wX; wT.y = wY; wT.z = wZ;
			}			
			function drawDepthMap(depthMap){
				var canvas = document.createElement("canvas");
				var context = canvas.getContext('2d');
				canvas.setAttribute('width', depthMap.width);
				canvas.setAttribute('height', depthMap.height);
				var image = context.getImageData(0, 0, depthMap.width, depthMap.height);
				for (var y = 0; y < depthMap.height; ++y) {
					for (var x = 0; x < depthMap.width; ++x) {
						var col = depthMap.depthMap[y * depthMap.width + x] / 50 * 255;
						image.data[4 * (y * depthMap.width + x) + 0] = col;
						image.data[4 * (y * depthMap.width + x) + 1] = col;
						image.data[4 * (y * depthMap.width + x) + 2] = col;
						image.data[4 * (y * depthMap.width + x) + 3] = 255;
					}
				}					
				context.putImageData(image, 0, 0);
				var dpeth_container = document.getElementById('depth_container');
				depth_container.appendChild(canvas);				
			}			
			function DAT_view(){
				//----- DAT GUI -----
				var gui = new dat.GUI();
				gui.add(this, "point_size", 0.1, 2.0).name("Point size").onChange(function (value) {
					point_cloud_material.size = point_size;
				});	
				gui.add(this, "show_pano", false).name("Show pano image").onChange(function (value) {
					if (value)
						document.getElementById("pano_container").className = "show";
					else
						document.getElementById("pano_container").className = "hide";
				});
				gui.add(this, "show_depth", false).name("Show depth").onChange(function (value) {
					if (value)
						document.getElementById("depth_container").className = "show";
					else
						document.getElementById("depth_container").className = "hide";
				});			
				gui.add(this, "trans", false).name("Axis trans").onChange(function (value) {
					if (value)
						street_view_heading_set.applyMatrix(new THREE.Matrix4().getInverse(matrix_set[0]));
					else
						street_view_heading_set.applyMatrix(matrix_set[0]);
				});	
				gui.add(text, 'imageIndex');
				gui.add(text, 'ptIndex');
				//gui.add(text, 'pano_x');
				//gui.add(text, 'pano_y');;
				//gui.add(text, 'depth_x');
				//gui.add(text, 'depth_y');
				sel = function() {
					var depth_container = document.getElementById("depth_container");
					
					//var color_canvas_x = parseInt((x / this.depthMap.width) * img_canvas_context.canvas.width);
					//var color_canvas_y = parseInt((y / this.depthMap.height) * img_canvas_context.canvas.height);
					
					var index = parseInt(text.ptIndex);
					
					var	imageIdx = parseInt(text.imageIndex);
					var canvas = depth_container.children[imageIdx];					
					text.depth_y = parseInt(index / canvas.width);							
					text.depth_x = parseInt(index % canvas.width);
					var context = canvas.getContext('2d');					
					context.fillStyle = "#FF0000";
					context.fillRect(text.depth_x-5,text.depth_y-5,10,10);					
					
					var canvasP = pano_container.children[imageIdx];
					text.pano_x = parseInt(text.depth_x / canvas.width * canvasP.width);
					text.pano_y = parseInt(text.depth_y / canvas.height * canvasP.height);
					var context = canvasP.getContext('2d');					
					context.fillStyle = "#FF0000";
					context.fillRect(text.pano_x-5,text.pano_y-5,10,10);							
					//street_view_heading_set.children[imageIdx].children[1].children[0].geometry.applyMatrix (matrix_set[imageIdx]);
					var XYZ = new THREE.Vector3(
						street_view_heading_set.children[imageIdx].children[1].children[0].geometry.attributes.position.array[index*3],
						street_view_heading_set.children[imageIdx].children[1].children[0].geometry.attributes.position.array[index*3 + 1],
						street_view_heading_set.children[imageIdx].children[1].children[0].geometry.attributes.position.array[index*3 + 2]
					)
					XYZ.applyProjection(matrix_set[imageIdx]);
					console.log(XYZ);
					var material = new THREE.LineBasicMaterial({ color: 0x0000ff }); 
					var geometry = new THREE.Geometry(); 
					geometry.vertices.push( 
						new THREE.Vector3( normal_set[imageIdx].x - normal_offs.x, normal_set[imageIdx].y - normal_offs.y, normal_set[imageIdx].z - normal_offs.z ),
						new THREE.Vector3(  XYZ.x, XYZ.y, XYZ.z)
					); 
					
					var line = new THREE.Line( geometry, material ); 
					street_view_heading_set.add( line );
				};				
				gui.add(this, "sel", false).name("Select point");	
			}
			function THREE_scene_init(){
				//----- THREE.JS OBJECT -----
				// Scene Create
				scene = new THREE.Scene();
				// Render
				renderer = new THREE.WebGLRenderer({
					antialias: true
				});				
				renderer.setClearColor( 0xffffff );
				renderer.setSize(window.innerWidth, window.innerHeight);
				// Container Created
				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
				// Camera Setting				
				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
				camera.position.set(0, 50, 0);
				camera.lookAt(0.0, 0.0, 0.0);
				camera.up.set(0.0, 1.0, 0.0)
				// Lights	
				light = new THREE.AmbientLight( 0xffffff );
				scene.add( light );
				// Controls && Project
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				raycaster = new THREE.Raycaster();
				// State Monitor
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );			
				// point cloud material
				point_cloud_material = new THREE.PointsMaterial({
					size: point_size,
					vertexColors: true,
					sizeAttenuation: true,
					fog: true
				});						
				// Point Cloud Objects
				scene.add(street_view_heading_set);		
				// world (x-z plane)
				var gridXZ = new THREE.GridHelper(1000, 50);
				gridXZ.setColors( new THREE.Color(0xff0000), new THREE.Color(0xffffff) );
				scene.add(gridXZ);				
			}
		</script>
	</body>
</html>
