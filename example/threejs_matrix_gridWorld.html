<!DOCTYPE html>
<html lang="en">
	<head>
		<title>simple_3d_3surface</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#pano_container {
				position:absolute;
				left:8px;
				top:48px;
				width:832px;
				height:416px;
				z-index:20;
				display:block;
				pointer-events:none;
				border:2px black solid;
			}
			#ground_container {
				position:absolute;
				left:8px;
				top:80px;
				width:512px;
				height:256px;
				z-index:40;
				display:block;
				pointer-events:none;
				border:2px black solid;
			}
			.hide {
				opacity:0;
				transition:opacity .5s ease-out;
			}
			.show {
				opacity:1;
				transition:opacity .5s ease-out;
			}
		</style>
	</head>

	<body>
		<div id="container" style="position:absolute; top:0px"></div>
		<div id="pano_container" class="hide"></div>	
		<div id="ground_container" class="hide"></div>
		
		<script src="../src/VideoSource/pathPoint.js"></script>
		
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/../build/three.min.js"></script>

		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/controls/OrbitControls.js"></script>
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/Detector.js"></script>
		<script src="../libs/mrdoob-three.js-5c6ec4a/examples/js/libs/stats.min.js"></script>
		
		<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
		
		<script type="text/javascript" src="../libs/dat.gui.min.js"></script>		

		<script src="../libs/GSVPanoDepth.js-master/examples/js/jquery.min.js" type="text/javascript"></script>
		<script src="../libs/GSVPanoDepth.js-master/examples/js/jquery.base64.min.js" type="text/javascript"></script>
		<script src="../libs/GSVPanoDepth.js-master/examples/js/zpipe.min.js" type="text/javascript"></script>

		<script src="js/GSVPano_my.js" type="text/javascript"></script>
		<script src="js/GSVPanoDepth_my.js" type="text/javascript"></script>			
		
		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			//Macapa,+AP,+¤Ú¦è
			//var pathPoint = [0.0324526,-51.0540268,0.0324385,-51.0538503,0.032426,-51.0536955,0.0324132,-51.0535362,0.0324028,-51.0534036,0.0324558,-51.0534274,0.0325456,-51.053422,0.0326443,-51.053416,0.032743,-51.05341,0.0329202,-51.0533991,0.0330548,-51.0533907,0.0332523,-51.0533784,0.033351,-51.0533722,0.0334596,-51.0533698,0.0335965,-51.0533633,0.0337711,-51.053345,0.0338696,-51.0533357,0.0339681,-51.0533263,0.0340576,-51.0533178,0.0341471,-51.0533093,0.0342367,-51.0533008];
			//Alta, Finnmark, Norge
			//var pathPoint = [69.9651823,23.27458,69.9650853,23.2747391,69.9650992,23.2748066,69.9651455,23.2750316,69.9652377,23.2754752,69.9652822,23.275689,69.9653305,23.2759206,69.9654362,23.2762605,69.9655197,23.2761058,69.9656109,23.2759371,69.9657532,23.2756268,69.9659061,23.2752685,69.9660671,23.2750026,69.9662141,23.2747421,69.9662105,23.2742806,69.9661245,23.2738803,69.9660845,23.273667,69.966048,23.2734562,69.9659841,23.2732486,69.9659011,23.273342,69.9657629,23.2735705,69.965692,23.2737075,69.9656183,23.2738,69.9655278,23.2740164,69.9654417,23.2741487,69.9653604,23.2742898,69.9652699,23.2744373];
			//Brighton Parade Southport, Queensland
			//var pathPoint = [-27.9779648,153.4160037,-27.978041,153.4158222,-27.9780782,153.4157334,-27.9781277,153.4156131,-27.9781771,153.4154975,-27.9782212,153.4153945,-27.9782604,153.4152917,-27.9782988,153.4151913,-27.9783499,153.4150954,-27.978401,153.4149995,-27.9784791,153.4148724,-27.9785428,153.4147886,-27.978688,153.4146426,-27.9788502,153.4145254,-27.9789304,153.4144834,-27.9790643,153.4144352,-27.9791919,153.4144129,-27.9793457,153.4144202,-27.9794594,153.4144285,-27.9795749,153.414437,-27.9796878,153.4144453,-27.9798556,153.4144585,-27.9800352,153.4144477,-27.9802593,153.4144176,-27.9804996,153.4143779] 

			//THREE.js
			var stats;
			var camera, controls, scene, renderer;
			//GOOGLE
			var svs = new google.maps.StreetViewService();
			//DAT
			var show_pano = false, show_ground = false;
			//POINT CLOUD
			var point_cloud_material, point_size = 0.1;			
			var root_street_view_set = new THREE.Object3D(), rtt;
			//----- TEXTURE -----
			var color_set = [], wT_set = [];
			//----- THREE SURFACE -----
			var planeLeft = [], planeRight = [], planeGnd;
			//----- POINT CLOUD COMPOSE -----	
			var wX0, wY0, wZ0, earthR = 6371000;
			//----- MineCraft like -----	
			var plane, cube, cubeSize = 3;
			var mouse, raycaster, isShiftDown = false;
			var rollOverMesh, rollOverMaterial;
			var cubeGeo, cubeMaterial;
			var objects = [];	
			//DEMO
			var pathLen = 4, pathStart = 0;
			init();
			animate();			
						
			function init() {
				//----- THREE.JS OBJECT -----
				// Scene Create
				scene = new THREE.Scene();
				// Render
				renderer = new THREE.WebGLRenderer({
					antialias: true
				});				
				renderer.setClearColor( 0xffffff );
				renderer.setSize(window.innerWidth, window.innerHeight);
				// Container Created
				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
				// Camera Setting				
				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
				camera.position.set(0, 50, 0);
				camera.lookAt(0.0, 0.0, 0.0);
				camera.up.set(0.0, 1.0, 0.0)
				// world (x-z plane)
				//var gridXZ = new THREE.GridHelper(1000, 50);
				//gridXZ.setColors( new THREE.Color(0xff0000), new THREE.Color(0xffffff) );
				//scene.add(gridXZ);
				// Lights	
				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 );
				scene.add( light );
				light = new THREE.DirectionalLight( 0x002288 );
				light.position.set( -1, -1, -1 );
				scene.add( light );
				light = new THREE.AmbientLight( 0x222222 );
				scene.add( light );
				// Controls && Project
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				//projector = new THREE.Projector();
				raycaster = new THREE.Raycaster();
				raycaster.params.PointCloud.threshold = 0.5;
				// State Monitor
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				//container.appendChild( stats.domElement );			
				// point cloud material
				point_cloud_material = new THREE.PointsMaterial({
					size: point_size,
					vertexColors: true,
					sizeAttenuation: true,
					fog: true
				});						
				// Point Cloud Objects
				scene.add(root_street_view_set);		

				//----- DAT GUI -----
				var gui = new dat.GUI();
				gui.add(this, "point_size", 0.1, 2.0).name("Point size").onChange(function (value) {
					point_cloud_material.size = point_size;
				});	
				gui.add(this, "show_pano", false).name("Show pano image").onChange(function (value) {
					if (value)
						document.getElementById("pano_container").className = "show";
					else
						document.getElementById("pano_container").className = "hide";
				});
				gui.add(this, "show_ground", false).name("Show ground").onChange(function (value) {
					if (value)
						document.getElementById("ground_container").className = "show";
					else
						document.getElementById("ground_container").className = "hide";
				});				
				//----- EVENT LISTENER -----
				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'onkeydown', onkeydown, false );
				//------------------
				// roll-over helpers
				rollOverGeo = new THREE.BoxGeometry( cubeSize, cubeSize, cubeSize );
				rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
				rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
				scene.add( rollOverMesh );
				// cubes
				cubeGeo = new THREE.BoxGeometry( cubeSize, cubeSize, cubeSize );
				cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( "textures/square-outline-textured.png" ) } );
				// grid
				var size = 90, step = cubeSize;
				var geometry = new THREE.Geometry();
				for ( var i = - size; i <= size; i += step ) {
					geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
					geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

					geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
					geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );
				}
				var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2, transparent: true } );
				var line = new THREE.LineSegments( geometry, material );
				scene.add( line );
				//
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				var geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
				geometry.rotateX( - Math.PI / 2 );

				plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
				scene.add( plane );

				objects.push( plane );
				
				//----- DEMO -----	
				pathPoint = pathPoint.slice(pathStart, pathPoint.length-1);
				for(var i=0;i<=0;i++){
					render_street_point_cloud(pathPoint[2*i], pathPoint[2*i+1],i);		
				}
			}		
			function render_street_point_cloud(lat, lon, index){
				//----- EACH SINGLE STREETVIEW -----
				var img_canvas_context = 0;
				var main_rotation = 0;
				var pano_loader = new GSVPANO.PanoLoader({
					zoom: 1
				});
				var depth_loader = new GSVPANO.PanoDepthLoader();	
				var root_street_view = new THREE.Object3D();	
				var street_view_heading = new THREE.Object3D();
				//World Axis to THREE.js Axis
				var wX, wY, wZ, wR, wT;
				wR = earthR*Math.cos(lat * Math.PI / 180.0);
				wY = earthR*Math.sin(lat * Math.PI / 180.0);
				wX = wR*Math.sin(lon * Math.PI / 180.0);
				wZ = wR*Math.cos(lon * Math.PI / 180.0);				
				wT = new THREE.Vector3(wX, wY, wZ);				
				if(index==0){
					wX0 = wX; wY0 = wY; wZ0 = wZ;
					wX = 0; wY = 0; wZ = 0;
				}
				else{
					wX = wX - wX0; wY = wY - wY0; wZ = wZ - wZ0;
				}		
				wT_set[index] = new THREE.Vector3(wX, wY, wZ);
				//----- LOAD PANO -----
				pano_loader.load(new google.maps.LatLng(lat,lon));
				pano_loader.onPanoramaLoad = function () {
					// Get Panoramic
					var pano_container = document.getElementById('pano_container');
					pano_container.appendChild(this.canvas);	
					// Get Other Links
					var root_helper_object = new THREE.Object3D();
					console.log(this.data.location.description);
					if (this.data.links.length > 0) {
						for (var i = 0; i < this.data.links.length; ++i) {
							// Draw arrow
							var helper_geometry_base = new THREE.Object3D();
							var helper_shape = new THREE.Shape();
							helper_shape.moveTo(0, 0);
							helper_shape.lineTo(-0.6, 1.25);
							helper_shape.lineTo(0.6, 1.25);
							helper_shape.lineTo(0, 0);
							var extrudeSettings = {
								amount: 0.25
							};
							extrudeSettings.bevelEnabled = false;
							var helper_geometry = new THREE.ExtrudeGeometry(helper_shape, extrudeSettings);
							var helper_mesh = new THREE.Mesh(helper_geometry, new THREE.MeshNormalMaterial())
							// Rotate heading && Place it
							helper_mesh.userData = this.data.links[i].pano;
							helper_mesh.rotation.x = Math.PI / 2.0;
							helper_mesh.position.z = -5;
							helper_geometry_base.rotation.y = -this.data.links[i].heading * Math.PI / 180;
							helper_geometry_base.add(helper_mesh);
							root_helper_object.add(helper_geometry_base);
						}
					}					
					root_street_view.add(root_helper_object);
					// Store PANO and HEADING, then call depth_loader
					img_canvas_context = this.canvas.getContext('2d');
					main_rotation = this.data.tiles.centerHeading;
					depth_loader.load(this.panoId);
				};
				
				//----- LOAD DEPTH -----
				depth_loader.onDepthLoad = function () {
					// Ground Map
					var color_data = img_canvas_context.getImageData(0, 0, img_canvas_context.canvas.width, img_canvas_context.canvas.height).data;
					color_set[index] = color_data;
					
					var canvas = document.createElement("canvas");
					var context = canvas.getContext('2d');
					canvas.setAttribute('width', this.depthMap.width);
					canvas.setAttribute('height', this.depthMap.height);
					var image = context.getImageData(0, 0, this.depthMap.width, this.depthMap.height);
					// Create Point Cloud
					var geometry = new THREE.BufferGeometry();
					var geometryTexture = new THREE.BufferGeometry();
					var num_points = this.depthMap.width * this.depthMap.height;
					var positions = new Float32Array(num_points * 3);
					var colors = new Float32Array(num_points * 3);					
					var n = 0;						
					for (var y = 0; y < this.depthMap.height; ++y) {
						for (var x = 0; x < this.depthMap.width; ++x) {
							// Plane
							var planeIndex = this._data.indices[y*this.depthMap.width + x];
							var planeN = new THREE.Vector3(this._data.planes[planeIndex].n[0], this._data.planes[planeIndex].n[1], this._data.planes[planeIndex].n[2]);
							var planeD = this._data.planes[planeIndex].d;
							if(planeN.angleTo(new THREE.Vector3(0,0,-1)) < 0.5){	
							//if(true){
								// Panoromic to Spherical
								var lat = -(y / this.depthMap.height) * 180.0 + 90.0;
								var lng = (x / this.depthMap.width) * 360.0 - 180.0;
								// Spherical Axis to THREE.js Axis
								var pos = new THREE.Vector3();
								pos.y = Math.sin(lat * Math.PI / 180.0);							
								var r = Math.cos(lat * Math.PI / 180.0);
								pos.x = (r * Math.sin(lng * Math.PI / 180.0));
								pos.z = -(r * Math.cos(lng * Math.PI / 180.0)); // IMPORTANT!!!!
								// Multiple by Depth
								var depth = parseFloat(this.depthMap.depthMap[y * this.depthMap.width + x]);
								//if(depth>50) continue;
								pos.multiplyScalar(depth);
								// Store Position and Color of Each Point
								positions[3 * n + 0] = isNaN(pos.x) ? 0 : pos.x;
								positions[3 * n + 1] = isNaN(pos.y) ? 0 : pos.y;
								positions[3 * n + 2] = isNaN(pos.z) ? 0 : pos.z;
								var color_canvas_x = parseInt((x / this.depthMap.width) * img_canvas_context.canvas.width);
								var color_canvas_y = parseInt((y / this.depthMap.height) * img_canvas_context.canvas.height);
								var color_index = color_canvas_y * img_canvas_context.canvas.width * 4 + color_canvas_x * 4;							
								colors[3 * n + 0] = (color_data[color_index + 0]) / 255.0;
								colors[3 * n + 1] = (color_data[color_index + 1]) / 255.0;
								colors[3 * n + 2] = (color_data[color_index + 2]) / 255.0;	
								// Ground texture
								image.data[4 * (y * this.depthMap.width + x) + 0] = color_data[color_index + 0];
								image.data[4 * (y * this.depthMap.width + x) + 1] = color_data[color_index + 1];
								image.data[4 * (y * this.depthMap.width + x) + 2] = color_data[color_index + 2];
								image.data[4 * (y * this.depthMap.width + x) + 3] = 255;
							}							
							n++;
						}
					}						
					// Ground texture
					context.putImageData(image, 0, 0);
					var groundImage = image;
					var ground_container = document.getElementById('ground_container');
					ground_container.appendChild(canvas);
					// Point Cloud geometry
					geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
					geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
					geometry.computeBoundingBox();
					var pointcloud = new THREE.Points(geometry, point_cloud_material);
					street_view_heading.add(pointcloud);
					
					street_view_heading.rotation.y = -main_rotation * Math.PI / 180.0;	
					root_street_view.add(street_view_heading);
					//----- World objects Regeisterd in GLWorld -----
					root_street_view.lookAt(wT);
					root_street_view.rotateOnAxis(new THREE.Vector3(1,0,0), Math.PI/2);
					root_street_view.position.x = wX;
					root_street_view.position.y = wY;
					root_street_view.position.z = wZ;
					root_street_view.updateMatrix();
					if(index==0){
						var dir = wT.clone().normalize().multiplyScalar(50);
						camera.position.set(dir.x, dir.y, dir.z);
						camera.lookAt(0.0, 0.0, 0.0);
						rtt = root_street_view;
					}			
					//sequence downloading pano
					if(index+1<pathLen){
						index++;
						render_street_point_cloud(pathPoint[2*index], pathPoint[2*index+1],index);							
					}
					else{/*
						//var geometry = new THREE.PlaneGeometry( 20, 60, 150, 450);
						var geometry = new THREE.PlaneGeometry( 20, 65, 200, 500);
						var material = new THREE.MeshLambertMaterial( { color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors } );
						
						var plane = new THREE.Mesh( geometry, material );													
						plane.lookAt(wT);
						plane.rotateOnAxis(new THREE.Vector3(0,0,1), -main_rotation * Math.PI / 180.0 );
						//plane.rotateOnAxis(new THREE.Vector3(0,1,0), Math.PI/2);
						plane.translateY(25);
						//plane.translateX(-6);
						plane.translateZ(-2.2);
						plane.updateMatrix();
						
						var yoo = new THREE.Mesh( geometry, material );													
						yoo.lookAt(wT);
						yoo.rotateOnAxis(new THREE.Vector3(0,0,1), -main_rotation * Math.PI / 180.0 );
						yoo.updateMatrix();	
						
						for ( var i = 0; i < geometry.vertices.length; i ++ ) {
							//var vec = geometry.vertices[i].clone().applyAxisAngle(wT.clone().normalize(), -main_rotation * Math.PI / 180.0);
							var indexx=0, minLen;
							var vec = geometry.vertices[i].clone().applyProjection(plane.matrix);
							var indexx = 5 - Math.floor(i*6/geometry.vertices.length);
							for(var ii=0; ii<wT_set.length; ii++){
								var curVec = new THREE.Vector3().subVectors(vec, wT_set[ii]);
								if(ii=0){
									minLen = curVec.length();
									indexx = 0;
								}
								else if(vec.length()<minLen){
									minLen = curVec.length();
									indexx = ii;
								}
							}	
							var vec = new THREE.Vector3().subVectors(vec, wT_set[indexx]);							
							var m4 = new THREE.Matrix4().getInverse(yoo.matrix);
							vec.applyProjection(m4);
							vec.applyAxisAngle(new THREE.Vector3(1,0,0), -Math.PI/2);
						
							lng = Math.atan(-vec.x / vec.z) / Math.PI * 180;
							if(vec.x>=0 && vec.z>=0) lng = lng + 180;							
							else if(vec.x<=0 && vec.z>=0) lng = lng - 180;
							r = new THREE.Vector3(vec.x, 0, vec.z).length();
							lat = Math.atan(vec.y / r) / Math.PI * 180;
							
							var color_canvas_x = parseInt(((lng + 180) / 360) * img_canvas_context.canvas.width);
							var color_canvas_y = parseInt((-(lat - 90) / 180) * img_canvas_context.canvas.height);
							var color_index = color_canvas_y * img_canvas_context.canvas.width * 4 + color_canvas_x * 4;
							
							color_data = color_set[indexx];
							geometry.colors[i] = new THREE.Color( (color_data[color_index + 0]) / 255.0, (color_data[color_index + 1]) / 255.0, (color_data[color_index + 2]) / 255.0 );
							
						}	
						// face color
						var faceIndices = [ 'a', 'b', 'c' ];
						for ( var i = 0; i < geometry.faces.length; i ++ ) {
							f  = geometry.faces[ i ];
							for( var j = 0; j < 3; j++ ) {
								vertexIndex = f[ faceIndices[ j ] ];
								//p = geometry.vertices[ vertexIndex ];
								//color = new THREE.Color( 0xffffff *Math.random() );
								//color.setHSL( ( p.y / radius + 1 ) / 2, 1.0, 0.5 );
								f.vertexColors[ j ] = geometry.colors[vertexIndex];
							}
						}														
						scene.add(plane)
						
						var bbox = new THREE.BoundingBoxHelper( root_street_view_set, new THREE.Color(0xFF9900));
						bbox.visible = false;
						bbox.update();
						//root_street_view.add( bbox );	
						var boxHelper = new THREE.BoxHelper( bbox ); // to remove the diagonals
						boxHelper.material.color.set( 0xff9000 );
						//scene.add( boxHelper );		*/						
						//root_street_view_set.applyMatrix(new THREE.Matrix4().getInverse(root_street_view.matrix));
						root_street_view_set.applyMatrix(new THREE.Matrix4().getInverse(rtt.matrix));
					}					
				}
				root_street_view_set.add(root_street_view);	
			}			

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true
				stats.update();
				
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}
			
			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					var intersect = intersects[ 0 ];

					rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
					rollOverMesh.position.divideScalar( cubeSize ).floor().multiplyScalar( cubeSize ).addScalar( cubeSize/2 );

				}

				render();

			}

			function onkeydown( event ) {

				event.preventDefault();

				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					var intersect = intersects[ 0 ];

					// delete cube

					if ( isShiftDown ) {

						if ( intersect.object != plane ) {

							scene.remove( intersect.object );

							objects.splice( objects.indexOf( intersect.object ), 1 );

						}

					// create cube

					} else {

						var voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( cubeSize ).floor().multiplyScalar( cubeSize ).addScalar( cubeSize/2 );
						scene.add( voxel );

						objects.push( voxel );

					}

					render();

				}

			}					
		</script>
	</body>
</html>
